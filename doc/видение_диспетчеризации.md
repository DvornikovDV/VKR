# Видение диспетчеризации и управления через виджеты

Версия: 1.0  
Статус: Draft  
Дата: 29.01.2026

---

## 1. Базовая цепочка для телеметрии (как сейчас видишь)

Разберём шаги на примере датчика температуры системы отопления:

1. Физический датчик измеряет температуру на объекте.  
2. Промежуточное устройство (контроллер, PLC, RTU, модуль сбора) публикует температуру по ModbusTCP (регистры/коилы).  
3. Edge‑сервер опрашивает этот ModbusTCP‑узел по расписанию (polling) и переводит «сырые» регистры в нормальные теги (например, `heating_01.sensors.supply_temp`).  
4. На Edge температура сохраняется в локальный кэш/БД и одновременно отдаётся в облако:  
   - либо через MQTT,  
   - либо через HTTP/WebSocket (у тебя — через Socket.IO).  
5. Центральный сервер принимает поток значений тегов и обновляет:  
   - хранилище телеметрии,  
   - realtime‑шину для клиентов Dashboard.  
6. Dashboard подписан по WebSocket/Socket.IO на обновления нужных тегов и при получении значения `heating_01.sensors.supply_temp` ищет все привязанные к нему виджеты (цифровые индикаторы, графики) и перерисовывает их.

В целом твоё понимание корректно: ModbusTCP → Edge → Socket.IO → центральный сервер → Dashboard → нужный виджет подсасывает своё значение по `tagId`.  
Важно, что **прямая логика в UI не привязана к Modbus**, она работает с абстрактными тегами и их значениями.

---

## 2. Управляющие команды: общая схема

Для управляющих действий (выключить помпу и т.п.) используется зеркальная цепочка в другую сторону:

```
[Виджет switch на схеме]
      ↓ (клик оператора)
[Frontend Dashboard]
      ↓ (формирование команды)
[Backend SCADA / Command API]
      ↓ (MQTT / прямой Modbus / HTTP к Edge)
[Edge‑сервер / контроллер]
      ↓
[Запись в Modbus‑регистр / coil]
      ↓
[Исполнительный механизм (помпа)]
      ↑
[Обратная связь по статусу (телеметрия)]
```

Ключевые принципы:

1. **Команда ≠ состояние**.  
   - Команда: «выключить помпу» (разовый импульс/запрос).  
   - Состояние: «помпа сейчас выключена» (устойчивое значение тега `0/1`).
2. **UI никогда не пишет напрямую в Modbus**.  
   Всегда есть backend/edge‑слой, который проверяет права, валидирует команду, пишет в устройство и контролирует обратную связь.
3. **Статус виджета берётся только из телеметрии**, а не из факта «кликнули кнопку».

---

## 3. Конфигурация виджета‑переключателя на схеме

### 3.1. Что хранится в bindings.json

Для виджета выключения помпы в `bindings.json` логично хранить два связанных элемента:

1. **Свитч (командный виджет):**
   ```json
   {
     "elementId": "elem_pump_switch_1",
     "tagId": "heating_01.devices.pump_state",     
     "tagName": "Отопление 1 – Помпа",
     "type": "switch",
     "onValue": 1,
     "offValue": 0,
     "commandTopic": "heating_01/pump/cmd"         
   }
   ```
2. **Индикатор состояния (лампочка/текст рядом):**
   ```json
   {
     "elementId": "elem_pump_status_1",
     "tagId": "heating_01.devices.pump_state",     
     "tagName": "Статус помпы",
     "type": "status-lamp",
     "onValue": 1,
     "offValue": 0
   }
   ```

Важные моменты:
- И свитч, и индикатор привязаны к **одному и тому же тегу состояния** `heating_01.devices.pump_state`.  
- Для команды используется отдельный канал (`commandTopic` или `commandEndpoint`), но результат команды всё равно отражается через этот же тег состояния.

### 3.2. Как это выглядит на схеме

На HMI:
- картинка помпы;  
- рядом иконка‑переключатель (виджет `elem_pump_switch_1`);  
- ещё рядом маленький индикатор/иконка или текст «Работает/Остановлена» (виджет `elem_pump_status_1`).

---

## 4. Пошаговый сценарий выключения помпы

### 4.1. Действия в Dashboard (frontend)

1. Оператор кликает по виджету `elem_pump_switch_1` на схеме.  
2. Виджет понимает текущее состояние по значению тега `heating_01.devices.pump_state` (например, сейчас `1` = ВКЛ).  
3. На клике формируется объект команды, например:
   ```json
   {
     "schemaId": "schema_heating_01",
     "elementId": "elem_pump_switch_1",
     "tagId": "heating_01.devices.pump_state",
     "desiredState": 0,
     "commandTopic": "heating_01/pump/cmd",
     "meta": {
       "userId": "operator_123",
       "source": "dashboard",
       "timestamp": "2026-01-29T03:00:00Z"
     }
   }
   ```
4. Frontend отправляет эту команду на backend через Socket.IO/WebSocket/HTTP POST, например:  
   - `socket.emit("command", payload)`  
   - или `POST /api/commands` с JSON.
5. В самом UI **по клику состояние не меняется немедленно** (чтобы не врать оператору). Вместо этого:  
   - можно показать «ожидание» (spinner/мигающий индикатор «исполнение команды»);  
   - или временно подсветить виджет как «pending».

### 4.2. Обработка команды на Backend SCADA

На стороне сервера происходит логика уровня контроля:

1. Принять команду от Dashboard.  
2. Проверить права пользователя (RBAC, роль «оператор», доступ к объекту `heating_01`).  
3. Провалидировать команду:  
   - допустимое ли значение `desiredState` (0/1),  
   - не в аварийном ли объекте состоянии и т.п.  
4. На основании `commandTopic`/`tagId` выбрать транспорт и формат:  
   - MQTT: опубликовать JSON или простое значение в топик `heating_01/pump/cmd`,  
   - или через REST к Edge‑серверу,  
   - или прямой ModbusTCP‑запрос к устройству (чаще это делает именно Edge).  
5. Сформировать низкоуровневую команду для контроллера:
   - Modbus: запись coils/holding register,  
   - MQTT: `{"cmd":"off"}` или `0`,  
   - др. протоколы.
6. Отправить команду в сторону Edge/контроллера.
7. Вернуть в Dashboard подтверждение приёма команды (не факт исполнения):  
   - `ack` / `commandId`.  
   Это можно отдать как отдельное событие: `command-accepted`.

### 4.3. Логика на Edge / контроллере

На Edge у тебя может быть простой командный обработчик:

1. Подписан на MQTT‑топик `heating_01/pump/cmd` или принимает HTTP‑запрос от сервера.  
2. Получает команду `desiredState = 0`.  
3. Переводит это в Modbus‑операцию: запись в coil или регистр помпы.  
4. После записи ждёт подтверждения либо:  
   - по Modbus (читает обратно регистр/coil),  
   - по физическому входу обратной связи (другой тег).  
5. Когда реальное состояние помпы стало `0` (выключена), Edge публикует новое значение тега `heating_01.devices.pump_state = 0` в MQTT/Socket.IO‑поток телеметрии.

### 4.4. Обратная связь в Dashboard

1. Центральный сервер получает от Edge обновление тега `heating_01.devices.pump_state = 0` (как обычную телеметрию).  
2. Пушит обновление во все подписанные клиенты Dashboard.  
3. Dashboard обновляет все виджеты, связанные с этим `tagId`:  
   - `elem_pump_switch_1` отрисовывает переключатель в положении «OFF»,  
   - `elem_pump_status_1` меняет цвет/текст на «Помпа остановлена».

Важно: виджеты **ничего не знают о Modbus или MQTT**, они просто реагируют на изменения тега и отправляют команды в "чёрный ящик" backend.

---

## 5. Типичный протокол команд на уровне backend ↔ Edge

Чтобы не путаться, удобно завести унифицированный формат команд на SCADA‑сервере и Edge.

### 5.1. Пример JSON‑формата команды

```json
{
  "commandId": "cmd-12345",
  "systemId": "heating_01",
  "tagId": "heating_01.devices.pump_state",
  "action": "set",
  "value": 0,
  "source": "dashboard",
  "userId": "operator_123",
  "createdAt": "2026-01-29T03:00:00Z"
}
```

Edge‑слой сам знает, как `tagId` мапится на конкретный Modbus‑адрес (coil/register) и что значит `value`.

### 5.2. Канал передачи

- MQTT: топик `heating_01/commands` с телом команды.  
- HTTP: `POST /api/edge/heating_01/commands`.  
- WebSocket: отдельный канал команд.

Важно, чтобы **обратная телеметрия была источником правды**, а не подтверждение команды. Команда могла отправиться, но не исполниться (авария, блокировка, нет связи).

---

## 6. Обработка ошибок и визуальный фидбек

Примеры ситуаций:

1. **Команда не принята backend:**
   - нет прав,  
   - некорректное значение,  
   - объект в аварии.  
   → Dashboard получает событие `command-rejected` с причиной, показывает оператору ошибку, состояние виджетов не меняет.
2. **Команда отправлена, но нет подтверждения от Edge:**
   - истёк таймаут ожидания изменения тега `pump_state`,  
   - связи с Edge нет.  
   → UI для этого виджета может подсветить ошибку (например, красная рамка/значок «нет связи»), а статус остаётся прошлым.
3. **Частичный успех:**  
   Например, команда прошла, но по телеметрии видно, что состояние переключилось и через секунду вернулось (защита, аварийный останов).  
   → Виджет покажет реальное состояние по тегу, а оператор через журнал событий увидит детальнее, что произошло.

Главная идея: **виджеты всегда отображают именно реальное состояние по тегу**, а команды лишь инициируют попытку сменить это состояние.

---

## 7. Как это встраивается в текущую архитектуру из scada-architecture.md

С учётом уже описанного дока `scada-architecture.md` структура получается такой:

1. `schema.json` — чистая геометрия и интерактивные элементы без привязок.  
2. `bindings.json` — карта связи элементов с тегами и командами, в том числе:  
   - `type: "sensor"` / `"status-lamp"` / `"switch"` / `"button"` и т.п.;  
   - `tagId` — единый ID для телеметрии и статуса;  
   - `commandTopic`/`commandEndpoint` — куда слать команды для данного элемента.
3. Backend:  
   - читает `bindings.json`,  
   - строит список тегов для подписки (для телеметрии),  
   - строит маппинг `elementId → (tagId, commandTopic, тип)` для команд,  
   - реализует API команд и прокидывает их на Edge/контроллеры.
4. Edge:  
   - знает соответствие `tagId → Modbus адрес`,  
   - опрашивает Modbus и публикует телеметрию по `tagId`,  
   - принимает команды по `tagId` и пишет их в Modbus.
5. Dashboard:  
   - рендерит схему из `schema.json`,  
   - загружает `bindings.json` для той же схемы,  
   - подписывается на поток значений тегов,  
   - рисует виджеты (индикаторы и переключатели) в соответствии с типом и конфигурацией,  
   - по клику на виджет формирует команду на backend.

Так виджеты становятся тонким UI‑слоем над универсальной моделью тегов, не зависящей от конкретного протокола (Modbus, MQTT и т.п.).

---

## 8. Краткое резюме

- Твоё представление по телеметрии (ModbusTCP → Edge → Socket.IO → Dashboard → виджет по `tagId`) корректно, нужно лишь формализовать слои и формат тегов.  
- Для команд используется тот же `tagId` для статуса, но отдельный канал/топик/endpoint для самой команды.  
- Виджет‑переключатель хранит в `bindings.json` не только `tagId`, но и `commandTopic` и значения `on/off`.  
- Цепочка команды: клик по виджету → JSON‑команда в backend → конвертация в низкоуровневую команду на Edge → запись в Modbus → обратная телеметрия → обновление статуса виджета.  
- Статус работы помпы всегда показывается с реального тега состояния, а не из "флага клика".

Этот подход хорошо ложится на `scada-architecture.md` и даёт понятную механику диспетчеризации через виджеты, не завязанную на конкретный протокол.
