# Анализ структуры данных для соединений

## Текущая структура: segments + points (ДУБЛИРОВАНИЕ)

**connection-meta содержит**:
```
segments: [{index, direction, start:{x,y}, end:{x,y}}, ...]
```

**Konva.Line требует**:
```
points: [x0, y0, x1, y1, x2, y2, ...] (плоский массив)
```

## Проблемы

### 1. Редундантность + рассинхронизация
- Одна геометрия хранится ДВАЖДЫ: segments (логика) + points (графика)
- Постоянные конверсии: `segmentsToPoints()`, `pointsToSegments()`
- Риск несинхронизации: если забыть обновить line.points() после изменения segments

**Пример проблемы**:
```
ДО:         line.points() = [x0,y0, x1,y1, x2,y2, x3,y3, x4,y4] (5 точек)
УДАЛИ:      segments = 3 объекта
ЗАБЫЛИ:     обновить line.points()
РЕЗУЛЬТАТ:  РАССИНХРОНИЗАЦИЯ!
```

### 2. Сложность операций с points
- При удалении разрыва: работаем с segments, потом переводим в points
- Нормализация требует сложной логики (из-за segments)
- Каждый шаг: удалить → пересчитать → нормализовать → конвертировать

### 3. Идиоматичность
- Не идиоматично: хранить segments для логики, points для рисования
- Лучше: единая модель данных

## Рекомендация: Вариант 2 (Организованные точки)

**Новая структура**:
```javascript
connection-meta = {
    id, fromPin, toPin,
    points: [{x, y}, {x, y}, ...],  // ЕДИНСТВЕННЫЙ источник истины
    handles: [],
    ...
}
```

**Преимущества**:
- Один источник истины: `points`
- Нет конверсий между segments/points
- Нормализация просто: цикл по points, проверка направления
- Операции простые: удалить `points.splice(idx, 2)` → `normalize()` → отрисовать

**Алгоритм нормализации**:
```javascript
function normalizeAllPoints(points, fromPin, toPin) {
    points[0] = {x: fromPin.x(), y: fromPin.y()};  // закреплена
    
    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i], p2 = points[i+1];
        if (p1.x !== p2.x) {
            p2.y = p1.y;  // горизонтальный сегмент
        } else {
            p2.x = p1.x;  // вертикальный сегмент
        }
    }
    
    points[points.length-1] = {x: toPin.x(), y: toPin.y()};  // закреплена
}
```

**Преобразование для Konva**:
```javascript
line.points(points.flatMap(p => [p.x, p.y]));
```

## План внедрения

1. Создать `normalizeAllPoints()` в ConnectionRouter
2. Перестроить `connection-meta.points` вместо segments (пока в новых соединениях)
3. Обновить `connection-editor.js`: работать с points, не segments
4. Обновить операции: удаления/добавления разрывов
5. Постепенно мигрировать остальной код

## Текущее состояние

✗ Работаем с segments (логика)
✗ Переводим в points (графика)
✗ Риск рассинхронизации везде

→ Нужна архитектурная рефакторизация
