# Алгоритм удаления сегментов соединения

## Основной принцип

При удалении сегмента из соединения удаляются **две соседние точки** (конечная и начальная удаляемого сегмента). После удаления необходимо **переподключить оставшиеся сегменты**, сохраняя ортогональность и направления базовых сегментов от пинов.

### Инварианты
- ✅ Направления первого и последнего сегментов **сохраняются** (они определены пинами)
- ✅ Пины **не перемещаются**
- ✅ Структура **остаётся ортогональной** (H и V чередуются)
- ✅ Промежуточные точки переместятся **минимально** (только необходимое выравнивание)

---

## Классификация соединений

### Тип A: Нечётное число сегментов (3, 5, 7, ...)

**Структура:**
```
Seg₀ — Point₁ — Seg₁ — Point₂ — Seg₂ — ... — Segₙ
H       (x,y)    V      (x,y)    H

Пример с 3 сегментами (4 точки):
H — Point — V — Point — H
```

**Характеристики:**
- Нечётное число сегментов → чётное число промежуточных точек
- Центральный сегмент всегда **V** (если Seg₀ = H)
- Существует **одна центральная точка** (между Seg₁ и Seg₂ в примере)

**Удаление:**
- Можно удалить **любой из двух центральных сегментов** (левый V или правый H после V)
- После удаления останется 2 промежуточные точки → нужно подгонять **одну из них** (центральную)

---

### Тип B: Чётное число сегментов (4, 6, 8, ...)

**Структура:**
```
Seg₀ — Point₁ — Seg₁ — Point₂ — Seg₂ — Point₃ — Seg₃ — ... — Segₙ
H       (x,y)    V      (x,y)    H      (x,y)    V

Пример с 4 сегментами (5 точек):
H — Point₁ — V — Point₂ — H — Point₃ — V
```

**Характеристики:**
- Чётное число сегментов → нечётное число промежуточных точек
- **Две центральные точки** (Point₂ и Point₃ в примере)
- Центральные сегменты: V и H (чередуются)

**Удаление:**
- Можно удалить **любой из двух центральных сегментов** (V или H)
- После удаления останется 3 промежуточные точки → нужно подгонять **две из них** (соседние с удалённым)

---

## Логика удаления

### Шаг 1: Валидация удаления

**Входные данные:**
- `segments` — массив сегментов
- `handleSegmentIndex` — индекс ручки (сегмента для удаления)

**Условия отказа:**
```
1. Нельзя удалять крайние (Seg₀ и Segₙ)
   → if (handleSegmentIndex === 0 || handleSegmentIndex === segments.length - 1)

2. Минимум сегментов:
   - Type A (нечётное): минимум 3 сегмента
   - Type B (чётное): минимум 4 сегмента
   
   → const isTypeA = segments.length % 2 === 1;
   → if (isTypeA && segments.length < 3)
   → if (!isTypeA && segments.length < 4)

3. Допустимые позиции удаления:
   - Type A: удалять можно только центральный сегмент(ы)
   - Type B: удалять можно только центральные сегменты(ы)
```

---

### Шаг 2: Определить тип соединения и позицию в группе центральных

**Определение типа:**
```
isTypeA = (segments.length % 2 === 1)

Пример:
- 3 сегмента → Type A (нечётное)
- 4 сегмента → Type B (чётное)
- 5 сегментов → Type A
```

**Центральные сегменты:**

Type A (нечётное, N сегментов):
```
Индекс центрального: center = (N - 1) / 2
Допустимые индексы удаления: [center]  (только один центральный)

Пример (N=5):
Seg₀ — Point — Seg₁ — Point — Seg₂ — Point — Seg₃ — Point — Seg₄
0               1               2 ← центр       3              4
Можно удалить: Seg₂
```

Type B (чётное, N сегментов):
```
Индексы центральных: left = N/2 - 1, right = N/2
Допустимые индексы удаления: [left, right]  (два центральных)

Пример (N=6):
Seg₀ — P — Seg₁ — P — Seg₂ — P — Seg₃ — P — Seg₄ — P — Seg₅
0       1        1       2        2       3        3      4       4       5
Можно удалить: Seg₂ или Seg₃
```

---

### Шаг 3: Преобразовать сегменты в массив точек

**Алгоритм:**
```
points = [fromPin.position()]

for each segment in segments:
    points.push(segment.end)

Результат: [P_fromPin, P₁, P₂, ..., Pₙ, P_toPin]
```

---

### Шаг 4: Удалить две точки

**Формула индекса первой точки для удаления:**
```
segmentIndexToRemove = handleSegmentIndex
firstPointIndex = segmentIndexToRemove + 1

Удалить: points[firstPointIndex] и points[firstPointIndex + 1]
```

**Почему?**
- Сегмент i заканчивается в points[i+1]
- Сегмент i+1 начинается в points[i+1] (совпадает)
- Сегмент i+1 заканчивается в points[i+2]
- Удаляя сегмент i и i+1 требует удалить points[i+1] и points[i+2]

---

### Шаг 5: Пересчитать сегменты из оставшихся точек

**Алгоритм:**
```
newSegments = []

for i from 0 to (points.length - 2):
    direction = определить_направление(points[i], points[i+1])
    
    segment = {
        index: i,
        direction: direction,
        start: points[i],
        end: points[i+1]
    }
    
    newSegments.push(segment)
```

**Функция определения направления:**
```
if (points[i].x === points[i+1].x):
    direction = 'V'  (вертикальный)
else if (points[i].y === points[i+1].y):
    direction = 'H'  (горизонтальный)
else:
    ERROR: нарушена ортогональность
```

---

### Шаг 6: Выровнять центральные точки

**Суть:** после удаления две точки остаются, но их координаты могут не совпадать с соседними. Нужно переместить центральную(ые) точку(и).

#### Type A (нечётное число сегментов, одна центральная точка)

**Перед выравниванием (пример с 3 сегментами после удаления из 5):**
```
Seg₀ — P₁ — Seg₁ — P_center — Seg₂
H      (100,50)  V   (150,50)   H

Seg₁ направлен вертикально (V), но P_center имеет Y = 50 (неправильно)
Seg₂ должен начинаться с Y координаты конца Seg₁
```

**Выравнивание (обход слева направо):**
```
for i from 0 to (newSegments.length - 2):
    curr = newSegments[i]
    next = newSegments[i + 1]
    
    // Конец текущего — начало следующего
    curr.end = {
        x: (curr.direction === 'H') ? curr.end.x : curr.start.x,
        y: (curr.direction === 'V') ? curr.end.y : curr.start.y
    }
    
    next.start = curr.end
    
    if next.direction === 'H':
        next.end.y = next.start.y  (выровнять Y)
    else:
        next.end.x = next.start.x  (выровнять X)
```

**Пример (Type A, 3 сегмента):**
```
Исходно:
Seg₀: H (100,50) → (200,50)
Seg₁: V (200,50) → (200,100)  ← центральная точка в start
P_center: (200,100)
Seg₂: H (200,100) → (250,100)

Seg₁.end совпадает с P_center, всё OK
```

---

#### Type B (чётное число сегментов, две центральные точки)

**Перед выравниванием (пример с 4 сегментов, 5 точек, удаляем один):**
```
Seg₀ — P₁ — Seg₁ — P_left — Seg₂ — P_right — Seg₃
H      (100,50)  V  (150,50)  H   (200,100)   V

P_left и P_right не совпадают в промежуточных значениях
```

**Выравнивание (обход слева направо, как в Type A):**
```
Same algorithm as Type A:
Каждый следующий сегмент начинается с конца предыдущего,
и выравнивается по своему направлению.
```

**Результат:**
```
Seg₀: H (100,50) → (200,50)       ← P₁ передвинулась на X=200
Seg₁: V (200,50) → (200,100)      ← P_left остаётся на Y=100
Seg₂: H (200,100) → (250,100)     ← P_right выровнялась
Seg₃: V (250,100) → (250,150)
```

---

### Шаг 7: Зафиксировать конечные координаты

**Последний сегмент должен заканчиваться в toPin:**
```
lastSeg = newSegments[newSegments.length - 1]

if lastSeg.direction === 'H':
    lastSeg.end.x = toPin.position().x
    lastSeg.end.y = lastSeg.start.y
else if lastSeg.direction === 'V':
    lastSeg.end.y = toPin.position().y
    lastSeg.end.x = lastSeg.start.x
```

---

### Шаг 8: Пересчитать индексы и обновить метаданные

```
for i from 0 to (newSegments.length - 1):
    newSegments[i].index = i

meta.segments = newSegments
meta.userModified = true
connection.setAttr('connection-meta', meta)
```

---

## Псевдокод полного алгоритма

```
function removeSegmentAtHandle(connection, handleSegmentIndex):
    // Шаг 1: Валидация
    segments = connection.segments
    
    if (handleSegmentIndex === 0 || handleSegmentIndex === segments.length - 1):
        return ERROR("Нельзя удалять крайние сегменты")
    
    isTypeA = (segments.length % 2 === 1)
    
    if (isTypeA && segments.length < 3):
        return ERROR("Минимум 3 сегмента для Type A")
    
    if (!isTypeA && segments.length < 4):
        return ERROR("Минимум 4 сегмента для Type B")
    
    // Шаг 3: Преобразовать в точки
    points = [fromPin.position()]
    for each seg in segments:
        points.push(seg.end)
    
    // Шаг 4: Удалить две точки
    pointIndexToRemove = handleSegmentIndex + 1
    points.splice(pointIndexToRemove, 2)
    
    // Шаг 5: Пересчитать сегменты
    newSegments = []
    for i from 0 to (points.length - 2):
        direction = determine_direction(points[i], points[i+1])
        newSegments.push({
            index: i,
            direction: direction,
            start: points[i],
            end: points[i+1]
        })
    
    // Шаг 6: Выровнять центральные точки
    for i from 0 to (newSegments.length - 2):
        curr = newSegments[i]
        next = newSegments[i + 1]
        next.start = curr.end
        
        if (next.direction === 'H'):
            next.end.y = next.start.y
        else:
            next.end.x = next.start.x
    
    // Шаг 7: Зафиксировать конец
    lastSeg = newSegments[newSegments.length - 1]
    if (lastSeg.direction === 'H'):
        lastSeg.end.x = toPin.position().x
        lastSeg.end.y = lastSeg.start.y
    else:
        lastSeg.end.y = toPin.position().y
        lastSeg.end.x = lastSeg.start.x
    
    // Шаг 8: Обновить
    for i in 0..newSegments.length:
        newSegments[i].index = i
    
    connection.segments = newSegments
    redrawConnection()
```

---

## Примеры пошагового выполнения

### Пример 1: Type A (5 сегментов, удаление центрального)

**Исходно:**
```
Seg₀:H (0,50)→(100,50)
Seg₁:V (100,50)→(100,100)
Seg₂:H (100,100)→(200,100)  ← удаляем
Seg₃:V (200,100)→(200,150)
Seg₄:H (200,150)→(300,150)

Points: [(0,50), (100,50), (100,100), (200,100), (200,150), (300,150)]
Удаляемый индекс: 2
Удаляемые точки: pointIndex 3,4 → (100,100), (200,100)

После удаления points:
[(0,50), (100,50), (200,150), (300,150)]

Новые сегменты (из points):
Seg₀:H (0,50)→(100,50)
Seg₁:V (100,50)→(200,150)  ← НАРУШЕНА ОРТОГОНАЛЬНОСТЬ
Seg₂:H (200,150)→(300,150)

Выравнивание:
- Seg₀ заканчивается в (100,50)
- Seg₁ начинается с (100,50), V → выровнять X
  → Seg₁.end.x = Seg₁.start.x = 100
  → Seg₁.end = (100, ?)
  
  Seg₁ должен дойти до (200,150)? НЕТ!
  Seg₁.direction = V → конец фиксируется по Y из оригинального направления
  → Нужно сохранить ориентацию
```

**КРИТИЧЕСКОЕ ЗАМЕЧАНИЕ:** логика выравнивания должна определить, куда именно должна вести Seg₁. Она должна соединить Seg₀.end с Seg₂.start, но сохраняя ортогональность.

**Исправленное выравнивание (обход):**
```
Seg₀: H (0,50) → (100,50)          ✓ не меняется

Seg₁: V начинается в (100,50)
      нужно достичь (200,150) где начинается Seg₂
      V: выравниваем X = start.x = 100
      конец Y — из следующего сегмента

      Seg₂: H (200,150) → (300,150), начинается в (200,150)
      Seg₁ должен закончиться, чтобы Seg₂ начался отсюда
      
      Seg₁.end = (Seg₁.start.x, Seg₂.start.y) = (100, 150)

Seg₂: H начинается в (100, 150)? НЕТ, в (200,150)
      Нужно добавить переходный H!
```

**Проблема:** после удаления двух точек может потребоваться **добавление переходного сегмента** для восстановления ортогональности!

---

### Пример 2: Type B (4 сегмента, удаление центрального)

**Исходно (6 точек):**
```
Points: [(0,50), (100,50), (100,100), (200,100), (200,150), (300,150)]

Seg₀:H (0,50)→(100,50)
Seg₁:V (100,50)→(100,100)
Seg₂:H (100,100)→(200,100)
Seg₃:V (200,100)→(200,150)

Удаляем Seg₁ (pointIndex 2,3 → (100,100), (200,100)):
Points after: [(0,50), (100,50), (200,150), (300,150)]

Новые сегменты:
Seg₀:H (0,50)→(100,50)
Seg₁:V (100,50)→(200,150)  ← ДИАГОНАЛЬ
Seg₂:H (200,150)→(300,150)

Выравнивание:
Seg₀.end = (100,50)
Seg₁.start = (100,50), V направлена вертикально
  → Seg₁.end.x = 100 (выравнять X, т.к. V)
  → Seg₁.end.y = ? (из Seg₂)
  
Seg₂ должна начаться откуда? Seg₂ начинается в (200,150)
  → Seg₁.end = (100, 150)

Seg₂.start = (100, 150)? НЕТ, она должна быть в (200, 150)
  → Нужен переходный H: (100, 150) → (200, 150)
```

---

## ВЫВОД И ИСПРАВЛЕНИЕ

**Проблема:** простое выравнивание по точкам недостаточно. После удаления двух точек может требоваться **добавление переходного сегмента**.

**Исправленный Шаг 6:**

```
После удаления двух точек и пересчёта сегментов:

for i from 0 to (newSegments.length - 2):
    curr = newSegments[i]
    next = newSegments[i + 1]
    
    // Если направления одинаковые или есть диагональное соединение
    // → вставить переходный сегмент
    
    if (curr.end.x !== next.start.x || curr.end.y !== next.start.y):
        // Несовпадение начала и конца
        // Вставить переходный сегмент
        
        transDir = (curr.direction === 'H') ? 'V' : 'H'
        
        transSegment = {
            direction: transDir,
            start: curr.end,
            end: (transDir === 'H') ? {x: next.start.x, y: curr.end.y} 
                                     : {x: curr.end.x, y: next.start.y}
        }
        
        newSegments.splice(i + 1, 0, transSegment)
        i++  // пропустить добавленный
    
    next.start = curr.end  // сохранить связь
```

Это гарантирует **восстановление ортогональности** и **автоматическое построение переходных сегментов**.

