# АНАЛИЗ ПРОБЛЕМ УДАЛЕНИЯ РАЗРЫВОВ СОЕДИНЕНИЙ

## ТИПЫ СОЕДИНЕНИЙ И СТРУКТУРА СЕГМЕНТОВ

### Тип 1: Соответствующие стороны (В\В, Н\Н, П\Л, Л\П)
- **Пример**: В→В (верх к верху), Н→Н (низ к низу)
- **Кол-во точек**: четное (2, 4, 6...)
- **Кол-во сегментов**: нечетное (1, 3, 5...)
- **Паттерн сегментов**: HVHV... или VHVH... (но в противоположном направлении)
- **Минимум для удаления**: 5 сегментов

| Точки | Сегменты | Формат | Пример | Удаляемо |
|---|---|---|---|---|
| 2 | 1 | H или V | Прямая горизонтальная | ❌ |
| 4 | 3 | HVH или VHV | Г базовое | ❌ |
| 6 | 5 | HVHVH или VHVHV | Г с разрывом | ✓ |

### Тип 2: НЕ соответствующие стороны (В\Л, В\П, Н\Л, Н\П)
- **Пример**: В→Л (верх к левому), Н→П (низ к правому)
- **Кол-во точек**: нечетное (3, 5, 7...)
- **Кол-во сегментов**: четное (2, 4, 6...)
- **Паттерн сегментов**: HVHV... или VHVH... (начинается с одного направления)
- **Минимум для удаления**: 4 сегмента

| Точки | Сегменты | Формат | Пример | Удаляемо |
|---|---|---|---|---|
| 3 | 2 | HV или VH | Г базовое | ❌ |
| 5 | 4 | HVHV или VHVH | Г с разрывом | ✓ |
| 7 | 6 | HVHVHV или VHVHVH | Г с 2 разрывами | ✓ |

---

## ПРОБЛЕМА 1: Неортогональные сегменты после удаления

### Текущая ситуация
```javascript
// Сейчас: просто удаляем 3 сегмента в 1, не пересчитываем координаты
const mergedSegment = {
    direction: leftSegment.direction,
    start: { x: leftSegment.start.x, y: leftSegment.start.y },
    end: { x: rightSegment.end.x, y: rightSegment.end.y }
};
segments.splice(handleSegmentIndex - 1, 3, mergedSegment);
```

### Почему возникает проблема
- Текущая логика **удаляет 3 сегмента и вставляет 1** (слияние)
- При удалении центрального разрыва координаты соседних сегментов не пересчитываются
- Это оставляет "оборванные" точки
- `normalizeSegments()` не может исправить, т.к. она работает неправильно

**Пример проблемы:**
```
ДО:  p1 --H--> mid.x,p1.y
     mid.x,p1.y --V--> mid.x,p2.y
     mid.x,p2.y --H--> p2

ПОСЛЕ (неправильно):
     p1 --H--> p2  (но координаты не обновлены!)
     p2.x ≠ mid.x, p2.y ≠ mid.x → нарушена ортогональность
```

### Решение (твоё предложение)
1. **Удалить только центральный сегмент** (не 3→1, а просто удалить средний)
2. **Пересчитать координаты соседних сегментов** так, чтобы:
   - Конец левого сегмента = начало следующего
   - Все сегменты остаются ортогональными

**Новый алгоритм:**
```javascript
// 1. Удалить только центральный сегмент
segments.splice(handleSegmentIndex, 1);

// 2. Пересчитать координаты в окрестности удаления
for (let i = Math.max(0, handleSegmentIndex - 1); 
     i < Math.min(segments.length - 1, handleSegmentIndex + 1); 
     i++) {
    const seg = segments[i];
    const nextSeg = segments[i + 1];
    // Соединить: конец текущего = начало следующего
    nextSeg.start.x = seg.end.x;
    nextSeg.start.y = seg.end.y;
}
```

---

## ПРОБЛЕМА 2: Ограничение `segments.length < 5` блокирует Г-соединения типа 2

### Текущая логика
```javascript
if (segments.length < 5) {
    console.warn('Нельзя удалить разрыв - недостаточно сегментов...');
    return;
}
```

### Почему это проблема
- **Г-соединение типа 2** (НЕ соответствующие стороны): `segments.length = 2` ✓
- **С одним разрывом**: `segments.length = 4` ❌ (заблокировано, но должно быть возможно!)
- **Удаление разрыва**: `4 → 3` (вернёт исходное Г с 2 сегментами) ✓

### Правило валидности (ИСПРАВЛЕНО)

**Тип 1** (четные точки, нечетные сегменты):
- **2 точки (1 сегмент)**: прямая, удалять нечего
- **4 точки (3 сегмента)**: Г базовое, **нельзя удалять** (потеряется ортогональность)
- **6 точек (5 сегментов)**: Г с разрывом, **можно удалить** → 4 точки (3 сегмента)
- **Минимум для удаления: 5 сегментов**

**Тип 2** (нечетные точки, четные сегменты):
- **3 точки (2 сегмента)**: Г базовое, **нельзя удалять**
- **5 точек (4 сегмента)**: Г с разрывом, **можно удалить** → 3 точки (2 сегмента)
- **7 точек (6 сегментов)**: Г с 2 разрывами, **можно удалить** → 5 точек (4 сегмента)
- **Минимум для удаления: 4 сегмента**

### Решение

**Новая валидация:**
```javascript
const isOddSegments = segments.length % 2 === 1;  // Type 1

if (isOddSegments) {
    // Type 1: требуется минимум 5 сегментов
    if (segments.length < 5) {
        console.warn('Нельзя удалить - недостаточно сегментов (минимум 5 для Type 1)');
        return;
    }
} else {
    // Type 2: требуется минимум 4 сегмента
    if (segments.length < 4) {
        console.warn('Нельзя удалить - недостаточно сегментов (минимум 4 для Type 2)');
        return;
    }
}
```

---

## НОВАЯ ЛОГИКА `removeBreakPointAtHandle()`

```javascript
removeBreakPointAtHandle(connection, handleSegmentIndex) {
    const meta = connection.getAttr('connection-meta');
    const segments = meta.segments;
    
    // 1. ЗАЩИТА: не удалять крайние разрывы (всегда)
    if (handleSegmentIndex === 0 || handleSegmentIndex === segments.length - 1) {
        console.warn('Нельзя удалить концевой разрыв');
        return;
    }
    
    // 2. ОПРЕДЕЛИТЬ ТИП
    const isType1 = segments.length % 2 === 1;  // нечетное = Type 1
    
    // 3. ВАЛИДАЦИЯ МИНИМУМА
    if (isType1) {
        // Type 1 (четные точки): min 5 сегментов
        if (segments.length < 5) {
            console.warn('Нельзя удалить - недостаточно сегментов (минимум 5 для Type 1)');
            return;
        }
    } else {
        // Type 2 (нечетные точки): min 4 сегмента
        if (segments.length < 4) {
            console.warn('Нельзя удалить - недостаточно сегментов (минимум 4 для Type 2)');
            return;
        }
    }
    
    // 4. УДАЛЕНИЕ: просто убираем центральный сегмент
    segments.splice(handleSegmentIndex, 1);
    
    // 5. ПЕРЕСЧЕТ КООРДИНАТ соседних сегментов
    this.recalculateSegmentCoordinates(segments, handleSegmentIndex);
    
    // 6. ОБНОВИТЬ метаданные
    for (let i = 0; i < segments.length; i++) {
        segments[i].index = i;
    }
    meta.segments = segments;
    meta.userModified = true;
    connection.setAttr('connection-meta', meta);
    
    // 7. ПЕРЕРИСОВАТЬ
    this.redrawConnection(connection);
    this.addLineEditHandles(connection);
    
    console.log(`Удален разрыв (segments: ${segments.length + 1} → ${segments.length})`);
}
```

---

## НОВАЯ ФУНКЦИЯ `recalculateSegmentCoordinates()`

```javascript
recalculateSegmentCoordinates(segments, deletionIndex) {
    // После удаления сегмента на позиции deletionIndex,
    // нужно пересчитать координаты соседних сегментов
    // Они должны стыковаться: конец[i] = начало[i+1]
    
    // Область пересчета: вокруг места удаления
    const startIdx = Math.max(0, deletionIndex - 1);
    const endIdx = Math.min(segments.length - 2, deletionIndex);
    
    for (let i = startIdx; i <= endIdx; i++) {
        const currentSeg = segments[i];
        const nextSeg = segments[i + 1];
        
        // Соединить сегменты в точке стыка
        nextSeg.start.x = currentSeg.end.x;
        nextSeg.start.y = currentSeg.end.y;
    }
}
```

---

## РЕЗЮМЕ

| Проблема | Причина | Решение |
|---|---|---|
| **1. Неортогональность** | Удаляем 3 сегмента в 1, не пересчитываем координаты | Удалить только центральный сегмент, пересчитать соседей |
| **2. Блокировка Г-типа 2** | Условие `< 5` неправильное для Type 2 | Использовать тип-зависимый минимум: Type1 min=5, Type2 min=4 |
| **3. Старая нормализация** | `normalizeSegments()` не работает | Заменить на `recalculateSegmentCoordinates()` с локальным пересчетом |
