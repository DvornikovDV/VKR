# Анализ проблем удаления разрывов соединений

## Проблема 1: Неправильное удаление точек

### Описание
При Ctrl+двойном клике по ручке иногда удаляются **3 точки + 2 сегмента**, а не **2 точки + 1 сегмент**.

### Причины
1. **Ошибка в расчёте индекса**: При конвертации индекса сегмента в индекс точки может произойти ошибка
   ```javascript
   // Текущий расчёт
   const pointIndexToRemove = handleSegmentIndex * 2;
   points.splice(pointIndexToRemove, 4);  // удаляем 4 элемента = 2 точки
   ```
   
   Проблема: если сегменты пересчитываются после удаления, и `normalizeAfterBreakRemoval` вызывает `splice` ещё раз, удаляется дополнительный сегмент.

2. **Слияние в `normalizeAfterBreakRemoval`**: При одинаковом направлении соседних сегментов вызывается `splice`, что может привести к удалению второго сегмента. Если это происходит при неправильном индексе, могут удалиться лишние данные.

### Решение
1. **Разделить операции**: Удаление точек → пересчёт сегментов → отдельно нормализация (без дополнительных splice на точках)
2. **Валидация**: После каждого шага проверить, что удалено ровно нужное количество сегментов
3. **Осторожнее со splice**: Убедиться, что в `normalizeAfterBreakRemoval` слияние H-H или V-V происходит на уровне сегментов, а не точек

---

## Проблема 2: Неправильная нормализация координат

### Описание
Текущая функция `normalizeAfterBreakRemoval` нормализует только соседние сегменты вокруг места удаления. Это создаёт ситуацию, когда:
- Две соседние точки стыкуются корректно
- Но остальная линия может остаться с нарушениями ортогональности
- Эффект накапливается при нескольких удалениях

### Причины
1. **Локальный подход**: Нормализуется только окрестность удаления, весь остальной путь остаётся нетронутым
2. **Отсутствие глобальной проверки**: Нет гарантии, что после нескольких операций весь путь будет ортогональным
3. **Проблема с неожиданными разломами**: Если точки стыков сместились, они могут нарушить ортогональность следующего сегмента

### Требования к алгоритму нормализации

#### Вариант 1: Глобальная проходка от первого пина
**Принцип**: Пройти по всем точкам с начала до конца, вычислив направление каждого сегмента и исправляя координаты по ходу.

```
процесс:
  points[0,1] = позиция первого пина (закреплена)
  для каждой пары сегментов (i, i+1):
    if direction[i] == 'H':
      // горизонтальный сегмент
      points[i+2].y = points[i].y  // конец сегмента на той же Y
    else:
      // вертикальный сегмент
      points[i+2].x = points[i].x  // конец сегмента на той же X
    
    // точка стыка между i и i+1 должна удовлетворять обоим
    if direction[i] != direction[i+1]:
      // разные направления — стык уже корректен по построению
      styk_point = points[i+2]
    else:
      // одинаковые направления — слить в один сегмент
      merge_segments(i, i+1)
      recalculate()
```

**Плюсы**:
- Универсален, работает независимо от истории изменений
- Обеспечивает полную ортогональность линии
- Детерминирован: всегда одинаковый результат

**Минусы**:
- Может смещать "внутренние" точки
- Требует полного пересчёта при каждом изменении

#### Вариант 2: Локальная нормализация с проверкой цепи
**Принцип**: Нормализовать только область удаления, но после этого проверить всю цепь и исправить разломы.

```
процесс:
  normalize_around_deletion()  // текущая функция
  
  for each segment pair (i, i+1):
    if has_orthogonality_break(i, i+1):
      fix_break(i, i+1)
```

**Плюсы**:
- Минимальный риск смещения других точек
- Быстрее (не пересчитываем всё)

**Минусы**:
- Сложнее в отладке
- Может остаться несогласованность в крайних случаях

---

## Рекомендуемое решение

**Для надёжности выбрать Вариант 1** (глобальная проходка от первого пина):

1. **Создать функцию `normalizeAllSegments(segments, fromPinPos)`**:
   - Начинает с позиции первого пина (закреплена)
   - Проходит по всем сегментам
   - Исправляет координаты каждой следующей точки
   - Сливает сегменты одинакового направления

2. **Вызывать вместо `normalizeAfterBreakRemoval`** при удалении разрывов

3. **Убедиться**:
   - Первая точка = позиция fromPin
   - Последняя точка = позиция toPin
   - Все сегменты чередуют H и V
   - Нет двух подряд сегментов с одинаковым направлением

---

## Тестовые сценарии

### Сценарий 1: Простое удаление из 5 сегментов
```
ДО:  p0 --H--> p1 --V--> p2 --H--> p3 --V--> p4 --H--> p5
Удалить разрыв на ручке 2 (V-сегмент)
ПОСЛЕ: p0 --H--> p1 --H--> p3 --V--> p4 --H--> p5
ОЖИДАНИЕ: H-H сливаются в один сегмент
РЕЗУЛЬТАТ: p0 --H-----> p3 --V--> p4 --H--> p5 (4 сегмента)
```

### Сценарий 2: Удаление с глобальной нормализацией
```
ДО:  pin1 --H--> p1 --V--> p2 --H--> p3 --V--> pin2
Удалить разрыв 2 (V-сегмент)
БЕЗ НОРМАЛИЗАЦИИ: pin1 --H--> p1' --H--> p3 --V--> pin2 (нарушение!)
С НОРМАЛИЗАЦИЕЙ: pin1 --H--> ... --V--> pin2 (ортогонально)
```

### Сценарий 3: Множественные удаления
```
ДО: 7 сегментов (Type 1)
Удалить разрыв 1 → 6 сегментов
Удалить разрыв 3 → 5 сегментов
ОЖИДАНИЕ: полная ортогональность после каждой операции
```

---

## Текущее состояние кода

### Файл: `public/connection-editor.js`

**Функция `removeBreakPointAtHandle`** (текущее состояние):
- ✓ Корректно вычисляет индекс удаления
- ✓ Удаляет 4 элемента из массива points (2 точки)
- ✓ Пересчитывает сегменты через `ConnectionRouter.pointsToSegments`
- ✗ Вызывает `normalizeAfterBreakRemoval` — **недостаточно**

**Функция `normalizeAfterBreakRemoval`** (текущее состояние):
- ✓ Проверяет направления соседних сегментов
- ✗ Только локальная нормализация
- ✗ Может оставить нарушения в других местах
- ✗ Слияние H-H / V-V может быть неправильным

---

## План реализации

1. **Добавить новую функцию `normalizeAllSegments(segments, fromPin, toPin)`**
   - Берёт первую точку = fromPin.position()
   - Проходит по каждому сегменту
   - Исправляет координаты по ходу
   - Сливает одинаковые направления

2. **Заменить вызов в `removeBreakPointAtHandle`**
   - Убрать `normalizeAfterBreakRemoval`
   - Вызвать `normalizeAllSegments` с передачей пинов

3. **Валидировать результат**
   - Проверить через `ConnectionRouter.validateSegments`
   - Логировать количество удалённых / оставшихся сегментов

4. **Тестирование**
   - Удаление разрывов в цепи из 5+ сегментов
   - Множественные удаления подряд
   - Проверка ортогональности после каждой операции
